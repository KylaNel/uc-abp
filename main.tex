\documentclass[sigconf,nonacm,screen]{acmart}
\settopmatter{printfolios=true}
\geometry{a4paper}

%% PACKAGES %%
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage[capitalise,nameinlink,noabbrev]{cleveref}
\usepackage{tikz}
\usepackage{tcolorbox}
\usepackage{amssymb}

\newcommand\extitem{\begin{tiny}$\blacksquare$ \end{tiny}}
\newcommand{\pluseq}{\mathrel{+}=}

\usepackage{lipsum} 

% % % % % % % % % % % % % % % % % % % % %
%          STUDENT INFORMATION 
% % % % % % % % % % % % % % % % % % % % %
\title{Universally Composable Anonymous Broadcast Protocols}

\author{Kyla Nel} %% ENTER YOUR NAME HERE!!!
\affiliation{
  \country{2576953n} %% ENTER YOUR MATRICULATION NUMBER HERE!!!
}


%% DOCUMENT %%

\begin{document}
% % % % % % % % % % % % % % % % % % % % %
% 			ABSTRACT
% % % % % % % % % % % % % % % % % % % % %

\begin{abstract}


\end{abstract}

%%%%%%%%%%%% DO NOT EDIT THIS PART!!! %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
\tikz [remember picture, overlay] %
\node [shift={(0.5cm,-0.5cm)}] at (current page.north west) %
[anchor=north west,scale=0.7] %
{\includegraphics{CompSci_logo.pdf}};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % % % % % % % % % % % % % % % % % % % %
% 			INTRODUCTION
% % % % % % % % % % % % % % % % % % % % %
\section{Introduction}
\label{sec:intro}

\section{Proof}

% Cases:
% \begin{enumerate}
%   \item U.r. (\textbf{sid}, WRITE, $|M|$, $P$) from functionality:
%   \begin{itemize}
%     \item Simulate a WRITE request on behalf of $P$ where $M_{Dummy}$ is all-zeroes
%     \item Generate $e_{\ell, M}$
%     \item $\mathcal{F}_{ZK}$ leaks nothing. $\mathcal{F}_{AEC}$ leaks the length of the message $|M|$, so the simulator sends $|M|$ to the adversary
%   \end{itemize}
%   \item U.r. $<M_1,...,M_k>$ from the functionality:
%   If Server A is corrupted, then
%   \begin{itemize}
%     \item Simulator sends a dummy message containing all zeroes over $\mathcal{F}_{AEC}$
%     \item Extract the subset of honest messages from the set of all messages.
%     \item Randomly assign honest messages to honest parties
%     \item Generate $e_{\ell,M}$ of the corresponding party and send $r$ to Server A, then $e_{\ell,M}\oplus r$ is the share of party $P$ for Server B
%   \end{itemize}
%   If Server B is corrupted, then
%   \begin{itemize}
%     \item Simulator equivocates by sending any $r$ to Server A
%     \item Extract the subset of honest messages from the set of all messages.
%     \item Randomly assign honest messages to honest parties
%     \item Construct a consistent $e_{\ell,M}$
%     \item Send $e_{\ell,M}\oplus r$ of the corresponding party to Server B
%   \end{itemize}
%   \item If an adversarial message is received, then 
%   \begin{itemize}
%     \item Simulator reconstructs M since it controls $\mathcal{F}_{AEC}$ and every $P$ is forced to send messages across the authenticated encrypted channel because all adversaries are passive
%     \item Tell the functionality to add M to the list of pending messages
%   \end{itemize}
% \end{enumerate}




% % % % % % % % % % % % % % % % % % % % %
% 	         BACKGROUND
% % % % % % % % % % % % % % % % % % % % %
\section{Background}
\label{sec:background}


Perhaps you want to cite the seminal paper of \citet{Turing1937}, or
prior~\cite{Goedel1931} and concurrent~\cite{Church1936} work.
% % % % % % % % % % % % % % % % % % % % %
% 			YOUR SYSTEM
% % % % % % % % % % % % % % % % % % % % %
\section{System Description}
\label{sec:system}

For the purposes of this dissertation, we examine a simple construction of Riposte which utilises two servers. Each server, $A$ and $B$, stores a table with $R$ rows and $C$ columns, where $C$ is the length of messages being sent, which we assume to be constant. Each "row" of the database table represents an index or space to which a message can be written. This database table is initialised to all zeros.
When a party wishes to send a message $M$, they first choose an index $\ell$ at random, then generate a random $R$ x $C$ bitstring $r$ and construct an $R$ x $C$ vector $e_{\ell,m}$ which contains zeros in each row except row $\ell$, which contains $M$. The party sends $r$ to Server $A$ and $r \oplus e_{\ell,M}$ to Server $B$. Here $\oplus$ represents bitwise XOR. Upon receiving the write request from the party, both servers first confirm that the party has not sent a valid write request in the current round already. If this is the party's first write request, Server $A$ writes $r$ into its database state and Server $B$ writes $r\oplus e_{\ell,M}$ into its database state. We assume the messages being written to the database are elements in some field $\mathbb{F}$ of prime charactersitic $p$. When a message is written to the database, it is added to the current database state by addition in $\mathbb{F}$. 

After processing $n$ write requests, Server $A$'s database state will be: $$d_A=r_1+...+r_n$$ and Server $B$'s database state will be: $$d_B=(r_1\oplus e_{{\ell,M}_1}) + ... + (r_n \oplus e_{{\ell,M}_n}).$$ Since both bitwise XOR and addition in $\mathbb{F}$ modulo $p$ are associative operations, Server $B$'s database state can be rearranged as follows: $$d_B = (r_1+..+r_n)\oplus(e_{{\ell,M}_1} + ... + e_{{\ell,M}_n})$$ which is clearly the same as $$d_B = d_A \oplus (e_{{\ell,M}_1} + ... + e_{{\ell,M}_n}).$$ The servers will continue to accept write requests until a pre-determined number of valid requests $K$ have been received. This marks the end of the current round. At the end of the round, the servers combine their local states $d_A$ and $d_B$ to reveal the plaintext database and broadcast this to all parties. The fact that any one party can only send one write request per round protects the system from denial-of-service attacks. Due to the obfuscation of of each message $M$ and its corresponding index $\ell$, neither server, nor the other parties, will know which party sent message $M$ or which location $\ell$ corresponds to $M$. Thus, write-privacy is maintained by this system. However, this does create a liveness problem in the system. Since a round does not end until $K$ write requests are received, if fewer than $K$ write requests are received, no messages will be broadcast at all, no matter how much time has elapsed in a current round. This problem is unavoidable if we do not want the anonymity set to be smaller than $K$.

\subsection{Collision Handling}
When a party $P_A$ wants to write the message $M_A\in \mathbb{F}$ to row $\ell$ in the database, the party actually writes the pair $(M_A,M_A^2)\in \mathbb{F}^2$ into row $\ell$. If no collision occurs, i.e. only one client writes their message to row $\ell$ in the database, recovering the original message is trivial. It is easy to check when this is the case, since the second coordinate will be the square of the first. In the case of a two-way collision, say party $P_B$ also writes their message pair $(M_B,M_B^2)\in \mathbb{F}^2$ to the same row $\ell$ in the database. Recall that when a message is written to the database, it is added to the current database state by addition in $\mathbb{F}$. Thus,  the message pair now contained in row $\ell$ of the database is $$S_1=M_A+M_B (\text{mod} p)$$ and $$S_2=M_A^2+M_B^2 (\text{mod}p).$$ Observing that $$2S_2-S_1^2=(M_A-M_B)^2(\text{mod}p)$$ we can obtain $M_A-M_B$ by taking a square root modulo $p$. Using $S_1=M_A+M_B$we can easily recover $M_A$ and $M_B$.

This way of handling two-way collisions can be generalised to $k$-way collision for $k>2$. Each party $P_i$ wanting to write their message $M_i$ into the database instead writes $(M_i,M_i^2,...,M_i^k)\in \mathbb{F}^k$ to its chosen row $\ell$. Now, if a $k$-way collision occurs, we have $k$ equations in $k$ variables which can be solved efficiently to recover all $k$ messages, as long as the characteristic $p$ of $\mathbb{F}$ is greater than $k$.

\subsection{Disruption Resistance}
Some disruption resistance is already provided by preventing any one party from sending more than one write request per round. However, in the above description of the system, there is nothing preventing a party from sending a malformed write request. For example, an adversary controlling several corrupted parties might instruct each of them to construct a vector $e_{\ell}$ containing a message in every row (instead of only in one row with zeros everywhere else as an honest party would do). A corrupted party could then generate a random vector $r$ as described above, and send $r$ to Server $A$ and $r\oplus e_\ell$ to Server $B$. If enough parties are corrupted, this could flood the system with messages.

To address this, a non-interactive zero knowledge proof is utilised for detecting disruptors. Zero knowledge techniques are applied to allow parties to prove that their write requests are well formed.


\section{Functionality \& Protocol}
\label{sec:func}

\input{riposte_uc_functionality}
\begin{table*}
\input{riposte_uc_protocol}
\end{table*}
\input{ae_functionality}
\input{zk_functionality.tex}
\input{bc_functionality.tex}

\section{Proof}
\label{sec:proof}


\textbf{Case 1:} We first examine the case where Server A is corrupted and $\mathcal{S}$ controls the honest Server B. Here $\mathcal{A}$ requests to corrupt Server A in the hybrid world and so S corrupts Server A in the ideal world. Upon receiving (\textbf{sid}, \textbf{WRITE}, |$M$|, $P$) from $\mathcal{F}_R^K$ where $P$ is an honest party, $\mathcal{S}$ simulates a \textbf{WRITE} request with a dummy all-zero message $M_0=0...0$ on behalf of $P$. In this case, $\mathcal{S}$ simulates the protocol as written, using the dummy message $M_0$ to generate $e_{\ell, M_0}$. LEAK DATA. Upon receiving (\textbf{sid}, \textbf{WRITE}, |$M^*$|, $P^*$) from $\mathcal{F}_R^K$ where $P^*$ is a corrupted party, $\mathcal{S}$ reconstructs $M^*$ from the two shares sent to Server A and Server B respectively across $\mathcal{F}_{AEC}(\{A,B\})$. This is made possible by the fact that parties are passively corrupted and so are forced to communicate using $\mathcal{F}_{AEC}$ exclusively, which $\mathcal{S}$ controls. Having reconstructed $M^*$, $\mathcal{S}$ then sends a WRITE request (\textbf{SID}, \textbf{WRITE}, $M^*$, $P^*$) to the functionality. Upon receiving (\textbf{sid}, \textbf{BROADCAST}, $<M_1,...,M_K>$) from $\mathcal{F}_R^K$, $\mathcal{S}$ extracts the subset of honest messages from $<M_1,...,M_K>$ and randomly assigns the honest messages to honest parties. For each honest party $P_i$ with associated message $M_i$, $\mathcal{S}$ constructs $e_{\ell,M_i}$ and creates the share $e_{\ell,M_i} \oplus r$. $\mathcal{S}$ sends $r$ to Server A and $e_{\ell, M_i}$ to Server B. At this stage, $\mathcal{S}$ must also simulate the WRITE request sent by the party $P_K$ which is associated with $M_K$, the $K$-th message added to $L_{pend}$. This follows the steps outlined above, depending on whether $P_K$ is honest or corrupted.

\textbf{Case 2:} Next, we examine the case where Server B is corrupted and $\mathcal{S}$ controls the honest Server A. In this case, $\mathcal{S}$ follows the same steps as in Case 1, however, $\mathcal{S}$ equivocates by sending any random bitsring $r$ to Server B. After the assignment of honest messages to honest partiews, $\mathcal{S}$ constructs a consistent $e_{\ell, M}$ for every honest message $M$ and sneds $e_{\ell, M}\oplus r$ to Server B.

In both cases, whatever is sent by the corrupted server when the servers combine their states, the results will be statistically indistuinguishable from the result if both servers were honest.


% % % % % % % % % % % % % % % % % % % % %
% 			EVALUATION
% % % % % % % % % % % % % % % % % % % % %
\section{Evaluation}
\label{sec:evaluation}

\subsection{Experimental Setup}


\subsection{Experimental Analysis}


% Our results are summarized in~\cref{tab:table1}, and a visual representation of
% our analysis can be seen in~\cref{fig:alice}.

% %% Example of table
% \begin{table}
% \footnotesize
% \begin{tabular}{lll}
% \toprule
%          & machine A                   & machine B                           \\
% \midrule
% CPU      & Intel Core i7-9700 CPU      & 2x Intel Xeon E5-2630 v3            \\
% CPU Frequency& 3.00GHz                     & 2.40GHz                             \\
% RAM      & 16GB DDR4                   & 128GB                               \\
% OS       & Ubuntu 20.04 LTS            & Ubuntu 16.04 LTS                    \\
% Compiler & GCC 9.3                     & GCC 7.3                             \\
% libm     & v2.31                       & v2.23                               \\
% libomp   & v4.5                        & v4.5                                \\
% \bottomrule
% \end{tabular}
% \caption{This is the table caption.}
% \label{tab:table1}
% \end{table}

%% Example of figure
% \begin{figure}
%     \centering
%     \includegraphics[width=0.8\columnwidth]{alice.pdf}
%     \caption{This is the figure caption.}
%     \label{fig:alice}
% \end{figure}




% % % % % % % % % % % % % % % % % % % % %
% 			CONCLUSIONS
% % % % % % % % % % % % % % % % % % % % %
\section{Conclusions}
\label{sec:conclusions}
\lipsum[1]




% % % % % % % % % % % % % % % % % % % % %
% 			ACKNOWLEDGMENTS
% % % % % % % % % % % % % % % % % % % % %
\section*{Acknowledgments}
I would like to thank \ldots

% % % % % % % % % % % % % % % % % % % % %
% 			BIBLIOGRAPHY
% % % % % % % % % % % % % % % % % % % % %
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}
\end{document}
